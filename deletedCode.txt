// This function sucks balls
int testPrint(const char* input){
    std::ifstream file(input);

    const int DAYS_ARRAY_SIZE = 32;


    std::string daysArray[DAYS_ARRAY_SIZE] = {};
    int tempsArray[2 * DAYS_ARRAY_SIZE] = {};

    int count = 0;

    std::string line;
    while ( count < DAYS_ARRAY_SIZE && std::getline( file, line ) )
    {
        std::istringstream is( line );
        is >> daysArray[count];
        is >> tempsArray[2 * count];
        is >> tempsArray[2 * count + 1];
    }

    for(const string& i : daysArray){
        std::cout << i;
    }
    std::cout << "\n";
    return 0;
}




SORTING ESTAB


void sortESTABA(){
    vector<pair<int,int> > pairs;
    map<string, ESTABdata>::iterator it;
    for(it = ESTAB.begin(); it != ESTAB.end(); it++){
        pairs.push_back(*it);
    }
    sort(pairs.begin(), pairs.end(), [=](std::pair<int, int>& a, std::pair<int, int>& b)
    {
        return a.second < b.second;
    }
    return; 
}
multimap<ESTABdata, string> sortESTAB(map<string,ESTABdata> & src) {

    multimap<ESTABdata,string> dst;

    for(typename map<A, ESTABdata>::const_iterator it = src.begin(); it != src.end(); ++it)
        dst.insert(pair<ESTABdata, string>(it -> second, it -> first));

    return dst;
}



ESTAB stuff

        
        // cout << "COUNT: " << count << endl;
        // string arg = vec[2];
        // cout << "Argument: " << arg << endl;
        // data.controlSection = programName;
        // data.address = atoi(vec[0].c_str());
        // data.instruction = arg;
        // ESTAB[arg] = data;

                // map<string,ESTABdata>::iterator it = ESTAB.find(arg);
        // if(it != ESTAB.end()){
        //     data.controlSection = programName;
        //     data.address = atoi(vec[0].c_str());
        //     data.instruction = arg;
        //     ESTAB[arg] = data;
        // }



ESTAB sorting stuff

// void sortESTAB(){

    
//     std::vector<std::pair<string, ESTABdata> > pairs;
//     for(map<string,ESTABdata>::size_type i = 0; i != ESTAB.size(); i++){
//         pairs.push_back(*ESTAB[i]);
//     }
    
//     // for (auto itr = freq.begin(); itr != freq.end(); ++itr)
//     //     pairs.push_back(*itr);

//     sort(pairs.begin(), pairs.end(), [=](std::pair<string, ESTABdata>& a, std::pair<string, ESTABdata>& b)
//     {
//         return a.second.address < b.second.address;
//     }
//     );
// }



// template<typename A, typename B>
// std::pair<B,A> flip_pair(const std::pair<A,B> &p)
// {
//     return std::pair<B,A>(p.second, p.first);
// }

// template<typename A, typename B>
// std::multimap<B,A> flip_map(const std::map<A,B> &src)
// {
//     std::multimap<B,A> dst;
//     std::transform(src.begin(), src.end(), std::inserter(dst, dst.begin()), 
//                    flip_pair<A,B>);
//     return dst;
// }


// template<string, ESTABdata>
// pair<string, ESTABdata> flip_pair(const pair<string, ESTABdata> &p)
// {
//     return pair<ESTABdata,string>(p.second.address,p.first);
// }

// template<string, ESTABdata>
// multimap<ESTABdata,string> flip_map(const map<string, ESTABdata) &src{
//     multimap<ESTABdata,string> dst;
//     transform(src.begin(), src.end(), inserter(dst, dsi.begin()), flip_pair<string, ESTABdata>);

//     return dst;
// }


// multimap<ESTABdata,string> reverseESTAB;
// void sortESTAB(){
//     reverseESTAB = flip_map(ESTAB);
// }










mod record shit

//cout << "Checking with size 4" << endl;
                string str = tokenized[i][2];
                vector<string> arguments = splitString(str);
                // cout << "SIZE: args: " << arguments.size() << endl;
                // cout << "SIZE: syms: "  << symbols.size() << endl;
                if(arguments.size() == 0 || arguments[0] == ""){
                    //cout << "CUTTING\n" << endl;
                    continue;
                }
                // for(int k = 0; k < arguments.size(); k++){
                //     cout << arguments[k] << endl;
                // }
                // cout << "---" << endl;
                // for(int p = 0; p < symbols.size(); p++){
                //     cout << symbols[p] << endl;
                // }
                // cout << endl;
                for(int j = 0; j < symbols.size(); j++){
                    for(int k = 0; k < arguments.size(); k++){
                        if(symbols[j] == arguments[k]){
                            
                            objectFile << "M"
                                   << "^"
                                   << setw(6)
                                   << setfill('0')
                                   << tokenized[i][0]
                                   << "^"
                                   << "05"
                                   << "^"
                                   << "+"
                                   << arguments[k]
                                   << endl;
                        }
                    }
                }



CURRENT:::


void modRecordAux(vector<string> symbols, 
                vector<vector<string> > tokenized, 
                string file, int i, int index){
    string temp = file.substr(0, file.find(".",0));
    temp += ".obj";
    ofstream objectFile;
    objectFile.open(temp.c_str(), ios_base::app);

    string str = tokenized[i][index];
    vector<string> arguments = splitString(str);
    // cout << "SIZE: args: " << arguments.size() << endl;
    // cout << "SIZE: syms: "  << symbols.size() << endl;
    if(arguments.size() == 0 || arguments[0] == ""){
        //cout << "CUTTING\n" << endl;
        return;
    }
    // for(int k = 0; k < arguments.size(); k++){
    //     cout << arguments[k] << endl;
    // }
    // cout << "---" << endl;
    // for(int p = 0; p < symbols.size(); p++){
    //     cout << symbols[p] << endl;
    // }
    //cout << endl;
    for(int j = 0; j < symbols.size(); j++){
        for(int k = 0; k < arguments.size(); k++){
            if(symbols[j] == arguments[k]){
                if(tokenized[i][1][0] == '+'){
                    unsigned int address;
                    istringstream converter(tokenized[i][0].c_str());
                    converter >> hex >> address;
                }
                objectFile << "M"
                        << "^"
                        << setw(6)
                        << setfill('0')
                        << tokenized[i][0]
                        << "^"
                        << "05"
                        << "^"
                        << "+"
                        << arguments[k]
                        << endl;
            }
        }
    }
    objectFile.close();
    return;
}

void generateModificationRecord(vector<string> sourceCode, 
        vector<vector<string> > tokenized, string file){

    // string temp = file.substr(0, file.find(".",0));
    // temp += ".obj";    
    // ofstream objectFile;
    // objectFile.open(temp.c_str(), ios_base::app);

    const unsigned int size = 30;
    unsigned int count;
    vector<string> symbols;
    for(int i = 0; i < tokenized.size(); i++){
        if(tokenized[i][0] == ".")              //Comment
            continue;
        else if(tokenized[i].size() < 3)        //End record
            continue;
        else if(tokenized[i][1] == "EXTREF"){   //populate external symbols 
            symbols = split(tokenized[i][2], ',');
        }
        else if(symbols.size() != 0){           //enter if external refs present
            if(tokenized[i].size() == 5){
                modRecordAux(symbols, tokenized, file, i, 3);
            } else if(tokenized[i].size() == 4){
                modRecordAux(symbols, tokenized, file, i, 4);
            }
        }
    }
    //objectFile.close();
    return;

}