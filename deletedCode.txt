// This function sucks balls
int testPrint(const char* input){
    std::ifstream file(input);

    const int DAYS_ARRAY_SIZE = 32;


    std::string daysArray[DAYS_ARRAY_SIZE] = {};
    int tempsArray[2 * DAYS_ARRAY_SIZE] = {};

    int count = 0;

    std::string line;
    while ( count < DAYS_ARRAY_SIZE && std::getline( file, line ) )
    {
        std::istringstream is( line );
        is >> daysArray[count];
        is >> tempsArray[2 * count];
        is >> tempsArray[2 * count + 1];
    }

    for(const string& i : daysArray){
        std::cout << i;
    }
    std::cout << "\n";
    return 0;
}




SORTING ESTAB


void sortESTABA(){
    vector<pair<int,int> > pairs;
    map<string, ESTABdata>::iterator it;
    for(it = ESTAB.begin(); it != ESTAB.end(); it++){
        pairs.push_back(*it);
    }
    sort(pairs.begin(), pairs.end(), [=](std::pair<int, int>& a, std::pair<int, int>& b)
    {
        return a.second < b.second;
    }
    return; 
}
multimap<ESTABdata, string> sortESTAB(map<string,ESTABdata> & src) {

    multimap<ESTABdata,string> dst;

    for(typename map<A, ESTABdata>::const_iterator it = src.begin(); it != src.end(); ++it)
        dst.insert(pair<ESTABdata, string>(it -> second, it -> first));

    return dst;
}



ESTAB stuff

        
        // cout << "COUNT: " << count << endl;
        // string arg = vec[2];
        // cout << "Argument: " << arg << endl;
        // data.controlSection = programName;
        // data.address = atoi(vec[0].c_str());
        // data.instruction = arg;
        // ESTAB[arg] = data;

                // map<string,ESTABdata>::iterator it = ESTAB.find(arg);
        // if(it != ESTAB.end()){
        //     data.controlSection = programName;
        //     data.address = atoi(vec[0].c_str());
        //     data.instruction = arg;
        //     ESTAB[arg] = data;
        // }



ESTAB sorting stuff

// void sortESTAB(){

    
//     std::vector<std::pair<string, ESTABdata> > pairs;
//     for(map<string,ESTABdata>::size_type i = 0; i != ESTAB.size(); i++){
//         pairs.push_back(*ESTAB[i]);
//     }
    
//     // for (auto itr = freq.begin(); itr != freq.end(); ++itr)
//     //     pairs.push_back(*itr);

//     sort(pairs.begin(), pairs.end(), [=](std::pair<string, ESTABdata>& a, std::pair<string, ESTABdata>& b)
//     {
//         return a.second.address < b.second.address;
//     }
//     );
// }



// template<typename A, typename B>
// std::pair<B,A> flip_pair(const std::pair<A,B> &p)
// {
//     return std::pair<B,A>(p.second, p.first);
// }

// template<typename A, typename B>
// std::multimap<B,A> flip_map(const std::map<A,B> &src)
// {
//     std::multimap<B,A> dst;
//     std::transform(src.begin(), src.end(), std::inserter(dst, dst.begin()), 
//                    flip_pair<A,B>);
//     return dst;
// }


// template<string, ESTABdata>
// pair<string, ESTABdata> flip_pair(const pair<string, ESTABdata> &p)
// {
//     return pair<ESTABdata,string>(p.second.address,p.first);
// }

// template<string, ESTABdata>
// multimap<ESTABdata,string> flip_map(const map<string, ESTABdata) &src{
//     multimap<ESTABdata,string> dst;
//     transform(src.begin(), src.end(), inserter(dst, dsi.begin()), flip_pair<string, ESTABdata>);

//     return dst;
// }


// multimap<ESTABdata,string> reverseESTAB;
// void sortESTAB(){
//     reverseESTAB = flip_map(ESTAB);
// }
